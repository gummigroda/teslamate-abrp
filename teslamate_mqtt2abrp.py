#!/usr/bin/python3

## [ CLI with docopt ]
"""TeslaMate MQTT to ABRP

Usage: 
    teslamate_mqtt2abrp.py [options] [ABRP_USER_TOKEN]

Arguments:
    ABRP_USER_TOKEN          User token generated by ABRP.

Options:
    --help                           Show this screen.
    -h, --mqttserver MQTT_SERVER     MQTT host to connect to.
    -P, --mqttport MQTT_PORT         MQTT server port.
    -u, --user MQTT_USERNAME         MQTT username.
    -p, --pass MQTT_PASSWORD         MQTT password.
    -t, --basetopic MQTT_BASE_TOPIC  Topic for messages and status, defaults to 'teslamate-abrp'.
    -c, --carnumber CAR_NUMBER       Car number from TeslaMate (usually 1).
    -m, --model CAR_MODEL            Car model according to https://api.iternio.com/1/tlm/get_CARMODELs_list
    -s --tls                         Use TLS connecting to MQTT server, environment variable: MQTT_TLS
    -x --skiplatlon                  Don't send LAT and LON to ABRP, environment variable: SKIP_LATLON

Note:
    All arguments can also be passed as corresponding OS environment variables using the capitalized variable.
"""

## [ IMPORTS ]
import sys
import datetime
import time
import calendar
import os
import paho.mqtt.client as mqtt
import requests
from time import sleep
from docopt import docopt

# Needed to initialize docopt (for CLI)
if __name__ == '__main__':
    arguments = docopt(__doc__)

## [ CONFIGURATION ]
APIKEY = "d49234a5-2553-454e-8321-3fe30b49aa64"
MQTTUSERNAME = None
MQTTPASSWORD = None
MQTTUSETLS = False
MQTTPORT = 1883
BASETOPIC = 'teslamate-abrp'
SKIPLOCATION = False

print("Parsing settings...")
# SERVER
if arguments['--mqttserver'] is not None: 
    MQTTSERVER = arguments['--mqttserver']
elif 'MQTT_SERVER' in os.environ: 
    MQTTSERVER = os.environ['MQTT_SERVER']
else: 
    sys.exit("MQTT server address not supplied. Please supply through ENV variables or CLI argument.")

# SERVER PORT
if arguments['--mqttport'] is not None: 
    MQTTPORT = int(arguments['--mqttport'])
elif 'MQTT_PORT' in os.environ is not None: 
    MQTTPORT = int(os.environ['MQTT_PORT'])

# USERNAME
if arguments['--user'] is not None: 
    MQTTUSERNAME = arguments['--user']
elif 'MQTT_USERNAME' in os.environ: 
    MQTTUSERNAME = os.environ['MQTT_USERNAME']

# PASSWORD
if arguments['--pass'] is not None:
    MQTTPASSWORD = arguments['--pass']
elif 'MQTT_PASSWORD' in os.environ: 
    MQTTPASSWORD = os.environ['MQTT_PASSWORD']

# BASE TOPIC
if arguments['--basetopic'] is not None: 
    BASETOPIC = arguments['--basetopic']
elif 'MQTT_BASE_TOPIC' in os.environ is not None: 
    BASETOPIC = os.environ['MQTT_BASE_TOPIC']

# USE TLS
if arguments['--tls']:
    MQTTUSETLS = True
elif "MQTT_TLS" in os.environ is not None: 
    MQTTUSETLS = True

# SKIP LAT LON
if arguments['--skiplatlon']:
    SKIPLOCATION = True
elif "SKIP_LATLON" in os.environ is not None: 
    SKIPLOCATION = True

# USER TOKEN
if arguments['ABRP_USER_TOKEN'] is not None: 
    USERTOKEN = arguments['ABRP_USER_TOKEN']
elif 'ABRP_USER_TOKEN' in os.environ: 
    USERTOKEN = os.environ['ABRP_USER_TOKEN']
else: 
    sys.exit("User token not supplied. Please generate it through ABRP and supply through ENV variables or CLI argument.")

# CAR NUMBER
if arguments['--carnumber'] is not None: 
    CARNUMBER = arguments['--carnumber']
elif 'CAR_NUMBER' in os.environ: 
    CARNUMBER = os.environ['CAR_NUMBER']
else:
    CARNUMBER = 1
    print("Car number not supplied, defaulting to 1.")

# CAR MODEL
if arguments['--model'] is not None: 
    CARMODEL = arguments['--model']
elif "CAR_MODEL" in os.environ: 
    CARMODEL = os.environ["CAR_MODEL"]
else: 
    CARMODEL = None

## [ VARS ]
state_topic = BASETOPIC + "/_script_status"
state = "" #car state
prev_state = "" #car state previous loop for tracking
charger_phases = 1
data = { #dictionary of values sent to ABRP API
    "utc": 0,
    "soc": 0,
    "power": 0,
    "speed": 0,
    "lat": 0,
    "lon": 0,
    "elevation": 0,
    "is_charging": False,
    "is_dcfc": False,
    "is_parked": False,
    "est_battery_range": 0,
    "ideal_battery_range": 0,
    "ext_temp": 0,
    "model": "",
    "trim_badging": "",
    "car_model":f"{CARMODEL}",
    "model": "",
    "trim_badging": "",
    "tlm_type": "api",
    "kwh_charged": 0,
    "heading": 0
}

## [ MQTT ]
# Initialize MQTT client and connect
client = mqtt.Client(f"teslamateToABRP-{CARNUMBER}")
if MQTTUSERNAME is not None:
    if MQTTPASSWORD is not None:
        print("Using MQTT username: {} and password '******'".format(MQTTUSERNAME))
        client.username_pw_set(MQTTUSERNAME, MQTTPASSWORD)
    else:
        print("Using MQTT username: {}".format(MQTTUSERNAME))
        client.username_pw_set(MQTTUSERNAME)
else:
    print("Connecting without any username or password")

# Last will
client.will_set(state_topic, payload="offline", qos=2, retain=True)
if MQTTUSETLS:
    print("Using TLS with MQTT")
    client.tls_set()
print("Trying to connect to {}:{}".format(MQTTSERVER,MQTTPORT))
client.connect(MQTTSERVER, MQTTPORT)

def niceNow():
    return datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

def on_connect(client, userdata, flags, rc):  # The callback for when the client connects to the broker
    # MQTT Error handling
    print("Connection returned result: {} CODE {}".format(mqtt.connack_string(rc),rc))
    if rc != 0:
        client.loop_stop(force=True)
        client.disconnect()
        raise SystemExit(1)
    client.publish(state_topic, payload="online", qos=2, retain=True)
    client.subscribe(f"teslamate/cars/{CARNUMBER}/#")

# Process MQTT messages
def on_message(client, userdata, message):
    global data
    global state
    #global charger_phases
    try:
        #extracts message data from the received message
        payload = str(message.payload.decode("utf-8"))

        #updates the received data
        topic_postfix = message.topic.split('/')[-1]

        if topic_postfix == "model":
            data["model"] = payload
            if CARMODEL is None: findCarModel()
        elif topic_postfix == "trim_badging":
            data["trim_badging"] = payload
        elif topic_postfix == "latitude":
            data["lat"] = float(payload)
        elif topic_postfix == "longitude":
            data["lon"] = float(payload)
        elif topic_postfix == "elevation":
            data["elevation"] = int(payload)
        elif topic_postfix == "speed":
            data["speed"] = int(payload)
        elif topic_postfix == "power":
            data["power"] = float(payload)
            if(data["is_charging"]==True and int(payload)<-22):
                data["is_dcfc"]=True
        elif topic_postfix == "charger_power":
            if(payload!='' and int(payload)!=0):
                data["is_charging"]=True
                if int(payload)>22:
                    data["is_dcfc"]=True
        elif topic_postfix == "heading":
            data["heading"] = int(payload)
        elif topic_postfix == "outside_temp":
            data["ext_temp"] = float(payload)
        elif topic_postfix == "odometer":
            data["odometer"] = float(payload)
        elif topic_postfix == "ideal_battery_range_km":
            data["ideal_battery_range"] = float(payload)
        elif topic_postfix == "est_battery_range_km":
            data["est_battery_range"] = float(payload)
        elif topic_postfix == "shift_state":
            if payload == "P":
                data["is_parked"]=True
            elif(payload == "D" or payload == "R" or payload == "N"):
                data["is_parked"]=False
        elif topic_postfix == "state":
            state = payload
            if payload=="driving":
                data["is_parked"]=False
                data["is_charging"]=False
                data["is_dcfc"]=False
            elif payload=="charging":
                data["is_parked"]=True
                data["is_charging"]=True
                data["is_dcfc"]=False
            elif payload=="supercharging":
                data["is_parked"]=True
                data["is_charging"]=True
                data["is_dcfc"]=True
            elif(payload=="online" or payload=="suspended" or payload=="asleep"):
                data["is_parked"]=True
                data["is_charging"]=False
                data["is_dcfc"]=False
        elif topic_postfix == "usable_battery_level": #State of Charge of the vehicle (what's displayed on the dashboard of the vehicle is preferred)
            data["soc"] = int(payload)
        elif topic_postfix == "charge_energy_added":
            data["kwh_charged"] = float(payload)
        elif topic_postfix == "charger_phases":
            charger_phases = 3 if int(payload) > 1 else 1

        # Calculate accurate power on AC charging
        #if data["power"] != 0.0 and data["is_charging"] == True and "voltage" in data and "current" in data:
        #    data["power"] = float(data["current"] * data["voltage"] * charger_phases) / 1000.0 * -1

        return

    except:
        print("unexpected exception while processing message:", sys.exc_info()[0], message.topic, message.payload)

# Starts the MQTT loop processing messages
client.on_message = on_message
client.on_connect = on_connect  # Define callback function for successful connection
client.loop_start()

## [ CAR MODEL ]
# Function to find out car model from TeslaMate data
def findCarModel():
    global data
    print("Trying to determine car model from TeslaMate data...")
    
    # Handle model 3 cases
    if data["model"] == "3":
        if data["trim_badging"] == "50":
            data["car_model"] = "3standard"
        elif data["trim_badging"] == "62":
            data["car_model"] = "3mid"
        elif data["trim_badging"] == "74":
            data["car_model"] = "3long"
        elif data["trim_badging"] == "74D":
            data["car_model"] = "3long_awd"
        elif data["trim_badging"] == "P74D":
            data["car_model"] = "3p20"
        else:
            print("Your Model 3 trim could not be automatically determined. Trim reported as: "+data["trim_badging"])
            return
    
    # Handle model Y cases
    if data["model"] == "Y":
        if data["trim_badging"] == "74D":
            data["car_model"] = "tesla:my:19:bt37:awd"
        elif data["trim_badging"] == "P74D":
            data["car_model"] = "tesla:my:19:bt37:perf"
        elif data["trim_badging"] == "50":
            data["car_model"] = "tesla:my:22:my_lfp:rwd"
        else:
            print("Your Model Y trim could not be automatically determined. Trim reported as: "+data["trim_badging"])
            return

    # Handle simple cases (aka Model S and Model X)
    else: 
        data["car_model"] = data["model"].lower()+""+data["trim_badging"].lower()

    # Log the determined car model to the console
    if data["car_model"] is not None: 
        print("Car model automatically determined as: "+data["car_model"])
    else: 
        print("Car model could not be automatically determined, please set it through the CLI or environment var according to the documentation for best results.")

## [ ABRP ]
# Function to send data to ABRP
def updateABRP(apiKey, userToken, dataObject):
    try:
        if not "car_model" in dataObject:
            print("Car model not found yet, waiting...")
            return
        if SKIPLOCATION:
            dataObject["lat"] = 0
            dataObject["lon"] = 0
        # Rinse
        del dataObject["_script_info"]
        # Send
        headers = {"Authorization": "APIKEY "+apiKey}
        body = {"tlm": dataObject}
        response = requests.post("https://api.iternio.com/1/tlm/send?token="+userToken, headers=headers, json=body)
        resp = response.json()
        if resp["status"] != "ok":
            print("Response from ABRP:", response.text)
    except Exception as ex:
        print("Unexpected exception while calling ABRP API:", sys.exc_info()[0])
        print(ex)
        publish_to_mqtt(
            {
                "_script_error_tst": niceNow(),
                "_script_error": ex
            }
        )

def publish_to_mqtt(dataObject):
    dataObject["_script_last_run"] = niceNow()
    for key, value in dataObject.items():
        client.publish(
            "{}/{}".format(BASETOPIC, key),
            payload=value,
            qos=1,
            retain=True
        )    

## [ MAIN ]
# Starts the forever loop updating ABRP
i = -1
while True:
    i+=1
    sleep(1) #refresh rate of 1 cycle per second
    if state != prev_state:
        i = 30
    current_datetime = datetime.datetime.utcnow()
    data["utc"] = calendar.timegm(current_datetime.utctimetuple()) #utc timestamp must be in every message
    
    if(state == "parked" or state == "online" or state == "suspended" or state=="asleep" or state=="offline"): #if parked, update every 30 cylces/seconds
        if "kwh_charged" in data:
            del data["kwh_charged"]
        if(i%30==0 or i>30):
            data["_script_info"] = "Car is {}, updating every 30s.".format(state)
            updateABRP(APIKEY, USERTOKEN, data)
            publish_to_mqtt(data)
            i = 0
    elif state == "charging": #if charging, update every 6 cycles/seconds
        if i%6==0:
            data["_script_info"] = "Car is {}, updating every 6s.".format(state)
            updateABRP(APIKEY, USERTOKEN, data)
            publish_to_mqtt(data)
    elif state == "driving": #if driving, update every cycle/second
        data["_script_info"] = "Car is {}, updating every second.".format(state)
        updateABRP(APIKEY, USERTOKEN, data)
        publish_to_mqtt(data)
    else:
        print("{} (unknown state), not sending any update to ABRP.".format(datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")))
        sleep(10)

    # Save state
    prev_state = state
